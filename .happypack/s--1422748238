'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _jsxFileName = '/home/spineor/Documents/risorso /newSetup_frontend/risorso/shared/components/DemoApp/AsyncPostsRoute/Post/Post.js';
exports.Post = Post;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _redux = require('redux');

var _reactRedux = require('react-redux');

var _reactJobs = require('react-jobs');

var _reactHelmet = require('react-helmet');

var _reactHelmet2 = _interopRequireDefault(_reactHelmet);

var _posts = require('../../../../actions/posts');

var PostActions = _interopRequireWildcard(_posts);

var _reducers = require('../../../../reducers');

var FromState = _interopRequireWildcard(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Post({ post }) {
  if (!post) {
    // Post hasn't been fetched yet. It would be better if we had a "status"
    // reducer attached to our posts which gave us a bit more insight, such
    // as whether the post is currently being fetched, or if the fetch failed.
    return null;
  }

  const { title, body } = post;

  return _react2.default.createElement(
    'div',
    {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 21
      }
    },
    _react2.default.createElement(_reactHelmet2.default, { title: `Posts - ${title}`, __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 22
      }
    }),
    _react2.default.createElement(
      'h1',
      {
        __self: this,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 24
        }
      },
      title
    ),
    _react2.default.createElement(
      'div',
      {
        __self: this,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 27
        }
      },
      body
    )
  );
}

function mapStateToProps(state, { match }) {
  return {
    post: FromState.getPostById(state, match.params.id)
  };
}

const mapActionsToProps = {
  fetchPost: PostActions.fetch
};

// We use the "compose" function from redux (but the lodash/ramda/etc equivalent
// would do the same), so that we can neatly attach multiple higher order
// functions to our component.
// They get attached to our component from a bottom up approach (i.e. the
// arguments of compose from right to left).
// Firstly the "withJob" is attached, indicating we want to do some async work.
// Then the redux "connect" is attached.
// This means the redux state and action will be passed through our "withJob".
// The job is meant to fire the fetching of a post.  If no post exists within
// the redux state it will fire the "fetchPost" redux-thunk action.  If you
// look at that action you will see it returns a Promise. It is a requirement
// to return a Promise when executing an asynchronous job so that the job
// runner knows when the job is complete.  You will also see that we first
// check to see if the post already exists within the state, if so we just
// return it which would then result in a synchronous execution of our component.
exports.default = (0, _redux.compose)((0, _reactRedux.connect)(mapStateToProps, mapActionsToProps), (0, _reactJobs.withJob)({
  work: ({ match, post, fetchPost }) => {
    if (post) {
      // We already have a post, just return true.
      return true;
    }

    // Execute the redux-thunk powered action that returns a Promise and
    // fetches the post.
    return fetchPost(match.params.id);
  },
  // Any time the post id changes we need to trigger the work.
  shouldWorkAgain: (prevProps, nextProps) => prevProps.match.params.id !== nextProps.match.params.id
}))(Post);


Post.propTypes = {
  post: _propTypes2.default.shape({
    title: _propTypes.string,
    body: _propTypes.string
  })
};

Post.defaultProps = {
  post: {}
};